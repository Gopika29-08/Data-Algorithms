Single File Programming Question
==============================
     1.Problem Statement
==============================
Aarav is building a simulation tool for chess movements as part of his computer science project.
He wants to analyze the movement of a knight on a square chessboard of size n x n. The knight starts
from a specific position (row, column) and makes exactly k moves. Each move is chosen uniformly at random from the 8 possible legal knight moves in chess.
Aarav is curious to discover the probability that the knight will still be on the board after making all the k moves.
Your task is to help Aarav by writing a program that calculates this probability.

Example:

Input:

3 2 0 0

Output:

0.06250

Explanation:

There are two moves (to (1,2), (2,1)) that will keep the knight on the board.
From each of those positions, there are also two moves that will keep the knight on the board.
The total probability that the knight stays on the board is 0.0625.
Input format :
The input consists of a single line of input containing four space-separated integers: n k row column

where:

n is the size of the chessboard (number of rows and columns),
k is the number of moves the knight makes,
row is the knight’s starting row (0-indexed),
column is the knight’s starting column (0-indexed).
Output format :
The output prints a single floating-point number rounded to 5 decimal places, representing the
probability that the knight remains on the board after k moves.

Refer to the sample output for formatting specifications.

Code constraints :
The given test cases fall under the following constraints:

1 ≤ n ≤ 25

0 ≤ k ≤ 100

0 ≤ row < n

0 ≤ column < n

Sample test cases :
Input 1 :
3 2 0 0
Output 1 :
0.06250
Input 2 :
5 2 2 2
Output 2 :
0.37500

=============================
        Program
=============================
#include<bits/stdc++.h>
using namespace std;
int dx[8] = {-2,-2,-1,-1,1,1,2,2};
int dy[8] = {-1,1,-2,2,-2,2,-1,1};

double SolKnight(int n,int k,int r,int c,vector<vector<vector<double>>> &dp){
    if(r<0 || r>=n || c<0 || c>=n)
        return 0;
    if(k==0)
        return 1;
    if(dp[r][c][k]!=-1)
        return dp[r][c][k];
    
    double prob = 0;
    for(int i=0;i<8;i++){
        int newRow = r+dx[i];
        int newCol = c+dy[i];
        prob+= SolKnight(n,k-1,newRow,newCol,dp)/8;
    }
    return dp[r][c][k]=prob;
}
int main(){
    int n,k,row,col;
    cin>>n>>k>>row>>col;
    vector<vector<vector<double>>> dp(n,vector<vector<double>>(n,vector<double>(k+1,-1)));
    double result = SolKnight(n,k,row,col,dp);
    cout<<fixed<<setprecision(5)<<result<<endl;
    return 0;
}


Single File Programming Question
=================================
     2.Problem Statement
=================================
In chess, each step of a knight comprises stepping by two squares horizontally and one square vertically,
or by one square horizontally and two squares vertically. A knight making one step from location (0,0)
of an infinite chess board would finish up at one of the following eight locations: (1,2), (−1,2), (1,−2), (−1,−2), (2,1), (−2,1), (2,−1), (−2,−1).

Beginning from location (0,0), what is the minimum number of steps needed for a knight to get to some other arbitrary location (x,y)?

Input format :
The first line of input contains two integers x and y, representing the location of a knight on a chess board.

Output format :
The output displays a single integer m, representing the minimum number of steps needed for a knight to move from (0,0) to (x,y).

Code constraints :
1 ≤ x, y ≤ 8

Sample test cases :
Input 1 :
1 2
Output 1 :
1
Input 2 :
2 4
Output 2 :
2

==============================
        Program
==============================
#include<bits/stdc++.h>
using namespace std;
int dx[8] = {1,-1,1,-1,2,-2,2,-2};
int dy[8] = {2,2,-2,-2,1,1,-1,-1};

int solKnights(int row,int col,int targetRow,int targetCol,int n){
    vector<vector<int>> board(n,vector<int>(n,0));
    queue<tuple<int,int,int>>q;
    board[row][col] = 1;
    q.emplace(row,col,0);
    while(!q.empty()){
        auto [r,c,steps] = q.front();
        q.pop();
        if(r==targetRow && c==targetCol)
            return steps;
        for(int i=0;i<8;i++){
           int newrow = r+dx[i];
           int newcol = c+dy[i];
           if(newrow>=0 && newrow<n && newcol>=0 && newcol<n && board[newrow][newcol]==0){
                board[newrow][newcol]=1;
                q.emplace(newrow,newcol,steps+1);
            }
        }
    }
    return -1;
}
int main(){
    int n=9;   // *assume n is greater than 8( n=9,10,11,etc..)
    int row,col;
    cin>>row>>col;
    int steps = solKnights(0,0,row,col,n);
    cout<<steps<<endl;
    return 0;
}

Single File Programming Question
====================================
       1.Problem Statement
====================================
John, a logistics manager, is tasked with finding the shortest delivery route between two warehouses
in a city using Dijkstra's algorithm. The city's road network is represented as a graph, where intersections are nodes and roads are weighted edges. 

Help John determine the quickest route between two warehouses based on the provided road network.

Input format :
The first line of input consists of an integer n, representing the number of intersections in the city.
The second line of input consists of an integer m, representing the number of roads connecting intersections.
The next m lines each contain three integers u, v, and w, where u and v are two intersections connected by a road of weight w.
The last two lines consist of integers source and destination, which represent the starting and destination intersections, respectively.

Output format :
If a path exists, the first line of output prints "Shortest path: " followed by the shortest path from the source to the destination, with each intersection separated by " -> ".
The second line prints "Shortest distance: " followed by the total distance of the shortest path.
If no path exists, output "No path found".

Refer to the sample output for formatting specifications.

Code constraints :
The given test cases fall under the following specifications:

1 ≤ n ≤ 100
1 ≤ m ≤ 100
0 ≤ u, v < n
0 ≤ w ≤ 100
0 ≤ s, d < n

Sample test cases :
Input 1 :
4
5
0 1 2
0 2 4
1 2 1
1 3 7
2 3 3
0
3
Output 1 :
Shortest path: 0 -> 1 -> 2 -> 3
Shortest distance: 6
Input 2 :
5
7
0 1 2
0 2 6
0 3 1
1 2 3
1 4 5
2 3 2
3 4 1
0
4
Output 2 :
Shortest path: 0 -> 3 -> 4
Shortest distance: 2
Input 3 :
3
2
0 1 5
1 2 3
0
2
Output 3 :
Shortest path: 0 -> 1 -> 2
Shortest distance: 8
Input 4 :
5
4
0 1 2
0 3 3
1 3 4
0 2 5
0
4
Output 4 :
No path found

=================================
          Program
=================================
#include<bits/stdc++.h>
using namespace std;
void dijkstra(int V,vector<vector<pair<int,int>>> &adj,int src,int dest){
    vector<int> dist(V,INT_MAX), parent(V,-1);
    priority_queue<pair<int,int>,vector<pair<int,int>>, greater<pair<int,int>>>pq;
    dist[src]=0;
    pq.push({0,src});
    while(!pq.empty()){
        int d = pq.top().first;
        int node = pq.top().second;
        pq.pop();
        
        if(d > dist[node])
            continue;
        for(auto edge : adj[node]){
            int nextNode = edge.first;
            int weight = edge.second;
            if(dist[node]+weight < dist[nextNode]){
                dist[nextNode] = dist[node] + weight;
                parent[nextNode] = node;
                pq.push({dist[nextNode], nextNode});
            }
        }
    }
    if(dist[dest] == INT_MAX){
        cout<<"No path found"<<endl;
        return;
    }
    
    vector<int> path;
    for(int v=dest;v!=-1;v=parent[v])
        path.push_back(v);
    reverse(path.begin(), path.end());
    
    cout<<"Shortest path: ";
    for(int i=0;i<path.size();i++){
        cout<<path[i];
        if(i!=path.size()-1)
            cout<<" -> ";
    }
    cout<<endl;
    cout<<"Shortest distance: "<<dist[dest]<<endl;
}
int main(){
    int n,m;
    cin>>n>>m;
    vector<vector<pair<int,int>>> adj(n);
    for(int i=0;i<m;i++){
        int u,v,w;
        cin>>u>>v>>w;
        adj[u].push_back({v,w});
    }
    int src,dest;
    cin>>src>>dest;
    dijkstra(n,adj,src,dest);
    return 0;
}

Single File Programming Question
=======================================
        2.Problem Statement
=======================================
You are tasked with finding the shortest communication paths from a source router to all other routers in a network using Dijkstra's algorithm. 
The network is represented as a graph, where routers are nodes and communication links between
them are edges with weights (representing the time or cost of communication).

Example

Input: 
source = 0, the graph is shown below.

Output: 
0 4 12 19 21 11 9 8 14

Explanation: 

The distance from 0 to 1 = 4.
The minimum distance from 0 to 2 = 12.
0->1->2
The minimum distance from 0 to 3 = 19.
0->1->2->3
The minimum distance from 0 to 4 = 21.
0->7->6->5->4
The minimum distance from 0 to 5 = 11.
0->7->6->5
The minimum distance from 0 to 6 = 9.
0->7->6
The minimum distance from 0 to 7 = 8.
0->7
The minimum distance from 0 to 8 = 14.
0->1->2->8

Input format :
The first line of input consists of the number of vertices, V in the graph.
The next lines of input consist of an adjacency matrix graph of size V x V representing the graph.
The last line of input consists of an integer representing the source vertex.

Output format :
For each vertex v, print the line v distance, where v is the vertex index and distance is the minimum distance from the source vertex to v in the following format:
"Vertex" followed by a space and then use tab space after print "Distance from Source"
vertex1 followed by three-tab spaces and then use a space after print source1.


Refer to the sample output for formatting specifications.

Code constraints :
The given test cases fall under the following specifications:
1 ≤ V ≤ 6
0 ≤ src < V
Edge weights are positive integers or zero.

Sample test cases :
Input 1 :
3
0 2 5
2 0 1
5 1 0
0
Output 1 :
Vertex 	Distance from Source
0			 0
1			 2
2			 3
Input 2 :
9
0 4 0 0 0 0 0 8 0
4 0 8 0 0 0 0 11 0
0 8 0 7 0 4 0 0 2
0 0 7 0 9 14 0 0 0
0 0 0 9 0 10 0 0 0
0 0 4 14 10 0 2 0 0
0 0 0 0 0 2 0 1 6
8 11 0 0 0 0 1 0 7
0 0 2 0 0 0 6 7 0
0
Output 2 :
Vertex 	Distance from Source
0			 0
1			 4
2			 12
3			 19
4			 21
5			 11
6			 9
7			 8
8			 14


====================================
           Program
====================================
#include<bits/stdc++.h>
using namespace std;
void dijkstra(int V, vector<vector<pair<int,int>>>& adj, int src){
    vector<int> dist(V,INT_MAX);
    dist[src] = 0;
    
    priority_queue<pair<int,int>, vector<pair<int,int>> , greater<pair<int,int>>> pq;
    pq.push({0,src});
    
    while(!pq.empty()){
        int d = pq.top().first;
        int node = pq.top().second;
        pq.pop();
        
        if(d>dist[node])
            continue;
        
        for(auto edge : adj[node]){
            int nextNode = edge.first;
            int weight = edge.second;
            
            if(dist[node]+weight < dist[nextNode]){
                dist[nextNode] = dist[node]+weight;
                pq.push({dist[nextNode], nextNode});
            }
        }
    }
    cout<<"Vertex \tDistance from Source"<<endl;
    for(int i=0;i<V;i++){
        cout<<i<<"\t\t\t "<<dist[i]<<endl;
    }
    
}
int main(){
    int V;
    cin>>V;
    vector<vector<int>> graph(V,vector<int>(V));
    for(int i=0;i<V;i++){
        for(int j=0;j<V;j++){
            cin>>graph[i][j];
        }
    }
    int src;
    cin>>src;
    vector<vector<pair<int,int>>>adj(V);
    for(int i=0;i<V;i++){
        for(int j=0;j<V;j++){
            if(graph[i][j]!=0){
                adj[i].push_back({j, graph[i][j]});
            }
        }
    }
    dijkstra(V,adj,src);
    return 0;
}

Single File Programming Question
===================================
      1.Problem Statement
===================================
The environmental department of a major city has collected daily Air Quality Index (AQI) data for the past N days.
The AQI score of each day is stored in a centralized database, where lower AQI values mean better air quality.
To support research and policy planning, the department must regularly answer queries such as: What was the best air quality recorded between Day L and Day R.

Since the AQI data is historical and fixed, and officials submit thousands of such range queries, your task is to
design a system that can preprocess the data once using a Sparse Table and answer each Range Minimum Query.

Input format :
The first line of the input consists of a single integer N representing the number of days the AQI data was recorded.
The second line of the input consists of N space-separated integers representing the AQI values for each day.
The third line of the input consists of a single integer Q, representing the number of queries.
The next Q lines each consist of two space-separated integers L and R, representing the range [L, R] (0-indexed) of days for which the minimum AQI is to be found.

Output format :
For each query, the output prints a single integer on a new line representing the minimum AQI value in the specified range [L, R].

Refer to the sample output for the formatting specifications.

Code constraints :
The given test cases fall under the following constraints:
1 ≤ N ≤ 20
1 ≤ Q ≤ 20
1 ≤ AQI[i] ≤ 100
0 ≤ L ≤ R < N

Sample test cases :
Input 1 :
6
4 2 7 1 3 6
4
0 2
1 4
2 5
3 3
Output 1 :
2
1
1
1
Input 2 :
8
5 3 8 6 2 9 1 7
5
0 7
2 5
4 6
1 1
6 7
Output 2 :
1
2
1
3
1

====================================
            Program
====================================
#include<bits/stdc++.h>
using namespace std;

int RMQ(int L,int R, vector<vector<int>> &st){
    int j = log2(R-L+1);
    return min(st[L][j], st[R-(int)pow(2,j)+1][j]);
}
int main(){
    int N;
    cin>>N;
    vector<int>AQI(N);
    for(int i=0;i<N;i++)
        cin>>AQI[i];
    int LOG = floor(log2(N))+1;
    vector<vector<int>> st(N, vector<int>(LOG));
    for(int i=0;i<N;i++)
        st[i][0]= AQI[i];
    for(int j=1;(int)pow(2,j)<=N;j++){
        for(int i=0;i+(int)pow(2,j)<=N;i++){
            st[i][j] = min(st[i][j-1], st[i+(int)pow(2,j-1)][j-1]);
        }
    }
    int Q;
    cin>>Q;
    while(Q--){
        int L,R;
        cin>>L>>R;
        cout<<RMQ(L,R,st)<<endl;
    }
    return 0;
}


Single File Programming Question
====================================
       2.Problem Statement
====================================
In a high-performance wireless communication grid, there are N signal towers aligned in a straight line. 
Each tower broadcasts a signal with varying strength, recorded once per day. To evaluate network stability, 
engineers must frequently analyze segments of the grid to identify the most reliable zones for stable coverage.

Given a range of towers [L, R] and a fixed segment length K, the engineers must determine the minimum of all maximum signal strengths over every K-length subsegment within [L, R].
To support this analysis efficiently, you are required to use a Sparse Table (also known as a Sparse Tree) to preprocess the signal strength data for fast Range Maximum Queries.

Input format :
The first line of the input consists of two integers, N and K, representing the number of towers and the fixed subsegment length to analyze.
The second line of the input consists of N space-separated integers representing the signal strengths recorded by each tower.
The third line of the input consists of a single integer Q, representing the number of queries.
The next Q lines each contain two space-separated integers L and R, representing the range of tower indices (0-based) to evaluate.

Output format :
For each query, the output prints a single integer on a new line representing the minimum of all K-length segment maximums in the range [L, R].

Refer to the sample output for the formatting specifications.

Code constraints :
The given test cases fall under the following constraints:
1 ≤ N ≤ 20
1 ≤ Q ≤ 20
1 ≤ K ≤ N
1 ≤ AQI[i] ≤ 100
0 ≤ L ≤ R − K + 1 < N

Sample test cases :
Input 1 :
8 3
60 72 55 80 65 90 50 78
2
0 4
2 5
Output 1 :
72
80
Input 2 :
10 4
88 95 70 85 60 92 76 80 69 74
2
1 6
3 9
Output 2 :
92
80

===================================
            Program
===================================
#include<bits/stdc++.h>
using namespace std;
int RMQ(int L, int R, vector<vector<int>> &st){
    int j = log2(R-L+1);
    return max(st[L][j], st[R-(int)pow(2,j)+1][j]);
}
int main(){
    int N,K;
    cin>>N>>K;
    vector<int>Signal(N);
    for(int i=0;i<N;i++)
        cin>>Signal[i];
    int LOG = floor(log2(N)+1);
    vector<vector<int>>st(N, vector<int>(LOG));
    for(int i=0;i<N;i++)
        st[i][0] = Signal[i];
    for(int j=1;(int)pow(2,j)<=N;j++){
        for(int i=0;i+(int)pow(2,j)<=N;i++){
            st[i][j] = max(st[i][j-1], st[i+(int)pow(2,j-1)][j-1]);
        }
    }
    int Q;
    cin>>Q;
    while(Q--){
        int L,R;
        cin>>L>>R;
        int ans = INT_MAX;
        for(int i=L;i<=R-K+1;i++){
            int segmentMax = RMQ(i,i+K-1, st);
            ans = min(ans, segmentMax);
        }
        cout<<ans<<endl;
    }
    return 0;
}

Single File Programming Question
==================================
      1.Problem Statement
==================================
Lily, a software engineer, needs to find all occurrences of a specific pattern in a larger text for her text analysis project. 

Given two strings txt (the text) and pat (the pattern) of sizes N and M respectively, where N > M,
help Lily by printing all starting indices of the pattern in the text using the KMP algorithm. 

Input format :
The first line of input consists of a string representing the text.

The second line consists of a string representing the pattern.

Output format :
The output prints the starting indices of all occurrences of the pattern in the text, using 0-based indexing.

Refer to the sample output for formatting specifications.

Code constraints :
The input consists of uppercase, lowercase alphabets and spaces (case-sensitive).

Sample test cases :
Input 1 :
sunshine
sun
Output 1 :
Found pattern at index 0
Input 2 :
AABAACAADAABAABA
AABA
Output 2 :
Found pattern at index 0
Found pattern at index 9
Found pattern at index 12
Input 3 :
This is a test text
test
Output 3 :
Found pattern at index 10

===================================
         Program
===================================
#include<bits/stdc++.h>
using namespace std;
void computeLPS(string &pattern, vector<int>&lps){
    int m = pattern.size();
    int len = 0;
    lps[0] = 0;
    int i=1;
    while(i<m){
        if(pattern[i] == pattern[len]){
            len++;
            lps[i] = len;
            i++;
        }
        else{
            if(len!=0){
                len = lps[len-1];
            }
            else{
                lps[i]=0;
                i++;
            }
        }
    }
}
int main(){
    string text,pattern;
    getline(cin,text);
    getline(cin,pattern);
    int n = text.size();
    int m = pattern.size();
    vector<int> lps(m);
    computeLPS(pattern, lps);
    int i=0;int j=0;
    while(i<n){
        if(text[i]==pattern[j]){
            i++;
            j++;
        }
        if(j==m){
            cout<<"Found pattern at index "<<i-j<<"\n";
            j= lps[j-1];
        }
        else if(i<n && text[i] != pattern[j]){
            if(j!=0){
                j= lps[j-1];
            }else{
                i++;
            }
        }
    }
}

Single File Programming Question
===================================
       2.Problem Statement
===================================
Sam is a high school student who loves solving puzzles and challenges in his computer science class.
One day, his teacher gave him an interesting problem related to palindromes. The task is to find the
shortest palindrome that can be created by adding characters only to the beginning of a given string.

Given a string s, Sam needs to write a program to find the shortest palindrome that can be formed by 
adding characters only to the beginning of the string using KMP algorithm.

Input format :
The input consists of a string s representing the input string.

Output format :
The output prints a string representing the shortest palindrome that can be formed by adding characters to the beginning of the string s.

Refer to the sample output for formatting specifications.

Code constraints :
2 < s.length â‰¤ 100

The string consists of lowercase English letters only.

Sample test cases :
Input 1 :
aacecaaa
Output 1 :
aaacecaaa
Input 2 :
abcd
Output 2 :
dcbabcd

================================
          Program
================================
#include<bits/stdc++.h>
using namespace std;

void computeLPS(string &pattern, vector<int> &lps){
    int m = pattern.size();
    int len = 0;
    lps[0] = 0;
    int i =1;
    while(i<m){
        if(pattern[i]==pattern[len]){
            len++;
            lps[i] = len;
            i++;
        }else{
            if(len!=0){
                len = lps[len -1];
            }else{
                lps[i] = 0;
                i++;
            }
        }
    }
}
int main(){
    string s;
    cin>>s;
    string rev = s;
    reverse(rev.begin(),rev.end());
    string combined = s+"#"+rev; //# -> for no overlapping 
    int m = combined.size();
    vector<int> lps(m);
    computeLPS(combined,lps);
    int longest =lps[m-1];
    string add = rev.substr(0,rev.size() - longest);
    cout<<add+s<<endl;
    return 0;
}






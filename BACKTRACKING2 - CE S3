Single File Programming Question
=============================
     1.Problem Statement
=============================

Given an undirected graph and a number m, determine if the graph can be colored with at most m colors such
that no two adjacent vertices of the graph are colored with the same color. 

Note: Here, the coloring of a graph means the assignment of colors to all vertices. 

Example

Input:

0 1 1 1

1 0 1 0

1 1 0 1

1 0 1 0

3


Output:

Solution Exists:

1 2 3 2


Explanation:

A minimum of 3 colors is required for the above graph.

Input format :
The input consists of four lines each containing four space-separated integers (1 if connected, 0 if not),
representing the adjacency matrix of a graph where each element represents the connection between vertices.

The last line consists of an integer m, representing the number of colors available.

Output format :
If a solution exists:

The first line prints "Solution Exists:".
The second line prints the assigned colors for each vertex, separated by a space.


If no solution exists, the output prints "Solution does not exist".

Refer to the sample output for the formatting specifications.

Code constraints :
The adjacency matrix has dimensions 4x4.

1 ≤ m ≤ 4

Sample test cases :
Input 1 :
0 1 1 1
1 0 1 0
1 1 0 1
1 0 1 0
3
Output 1 :
Solution Exists:
1 2 3 2 
Input 2 :
0 1 1 1
1 1 1 0
1 1 1 1
1 1 1 1
2
Output 2 :
Solution does not exist

============================
        Program
============================
#include<bits/stdc++.h>
using namespace std;
//Function to check if its safe to color vertes v with color c
bool isSafe(int v,vector<vector<int>> &graph,vector<int> &color,int c){
    for(int i=0;i<graph.size();i++){
        if(graph[v][i] && color[i] == c) //adjacent and same color
            return false;
    }
    return true;
}
 
//Recursive function to solve M-coloring problem
bool graphColorUntil(vector<vector<int>> &graph, int m,vector<int> &color,int v){
    if(v==graph.size())
        return true;   //all vertices are colored 
    for(int c=1;c<=m;c++){  //try all colors
        if(isSafe(v,graph,color,c)){
            color[v] = c;
            if(graphColorUntil(graph,m,color,v+1))
                return true;
            color[v] = 0;  //backtrack
        }
    }
    return false; //no color can be assigned
}

bool graphColoring(vector<vector<int>> &graph, int m){
    vector<int>color(graph.size(),0);
    if(!graphColorUntil(graph,m,color,0)){
        cout<<"Solution does not exist\n";
        return false;
    }
    cout<<"Solution Exists:"<<endl;
    for(int i=0;i<color.size();i++)
        cout<<color[i]<<" ";
    cout<<endl;
    return true;
}

int main(){
    int n=4;
    vector<vector<int>>graph(n, vector<int>(n));
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            cin>>graph[i][j];
        }
    }
    int m;
    cin>>m;
    graphColoring(graph,m);
    return 0;
}

Single File Programming Question
===============================
     2.Problem Statement
===============================


You are given a graph with a set of vertices and edges. The task is to determine if it can be colored using
a given number of colors such that no adjacent vertices have the same color. 

If possible, the program should print the assigned colors for each vertex; otherwise, it should indicate that no valid coloring exists.

Input format :
The first line contains an integer V, representing the number of vertices in the graph.

The next V lines contain the adjacency matrix of the graph, where each line consists of V space-separated
integers (0 or 1) representing the presence or absence of edges between vertices.

The last line contains an integer m, representing the number of colors available for coloring.

Output format :
If a valid coloring exists, the output prints the assigned colors for each vertex, separated by spaces.

If no valid coloring exists, the output prints "Solution does not exist".

Refer to the sample output for the formatting specifications.

Code constraints :
1 ≤ V ≤ 100

1 ≤ m ≤ V

Sample test cases :
Input 1 :
4
0 1 1 1
1 0 1 0
1 1 0 1
1 0 1 0
3
Output 1 :
1 2 3 2 
Input 2 :
3
0 1 1
1 0 0
1 0 0
2
Output 2 :
1 2 2 
Input 3 :
4
0 1 0 1
1 0 0 1
0 0 0 0
1 1 0 0
2
Output 3 :
Solution does not exist

=====================================
         Program
=====================================
#include<bits/stdc++.h>
using namespace std;

bool isSafe(int v,vector<vector<int>> &graph,vector<int>&color,int c){
    for(int i=0;i<graph.size();i++){
        if(graph[v][i] && color[i] == c)
           return false;
    }
    return true;
}

bool graphColorUntil(vector<vector<int>>&graph,int m,vector<int> &color,int v){
    if(v==graph.size())
        return true;
    for(int c=1;c<=m;c++){
        if(isSafe(v,graph,color,c)){
            color[v] = c;
            if(graphColorUntil(graph,m,color,v+1))
                return true;
            color[v] = 0;
        }
    }
    return false;
}

bool graphColoring(vector<vector<int>> &graph,int m){
    vector<int>color(graph.size(),0);
    if(!graphColorUntil(graph,m,color,0)){
        cout<<"Solution does not exist"<<endl;
        return false;
    }
    for(int i=0;i<color.size();i++)
        cout<<color[i]<<" ";
    cout<<endl;
    return true;
}
int main(){
    int n;
    cin>>n;
    vector<vector<int>> graph(n,vector<int>(n));
    for(int i=0;i<n;i++){
        for(int j=0;j<n;j++){
            cin>>graph[i][j];
        }
    }
    int m;
    cin>>m;
    graphColoring(graph,m);
    return 0;
}
